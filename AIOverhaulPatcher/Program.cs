using System;
using System.Collections.Generic;
using System.Linq;
using Mutagen.Bethesda;
using Mutagen.Bethesda.Synthesis;
using Mutagen.Bethesda.Skyrim;
using AIOverhaulPatcher.Utilities;
using AIOverhaulPatcher.Settings;
using Noggog;
using System.Text.RegularExpressions;
using System.Threading.Tasks;
using Mutagen.Bethesda.Plugins; 

namespace AIOverhaulPatcher
{
    public class Program
    {
        private static Lazy<Settings.Settings> _settings = null!;
        const string AioPatchName = "AIOPatch.esp";
        public static Task<int> Main(string[] args)
        {
            // Diagnostic: log raw args received so we can see how Synthesis forwards them.
            Console.WriteLine($"Raw args length: {args.Length}");
            for (int _i = 0; _i < args.Length; _i++)
                Console.WriteLine($"arg[{_i}]: '{args[_i]}'");

            // If Synthesis (or other caller) passes the entire app argument string as a single
            // quoted argument, split it into proper args here so the pipeline receives them.
            if (args.Length == 1)
            {
                var single = args[0];
                if (single.Contains("--DataFolderPath") || single.Contains("run-patcher") || single.Contains("--PatcherName"))
                {
                    args = SplitArgs(single);
                }
            }

            // If we still don't have useful args (Synthesis may invoke `dotnet run` so the
            // host command-line contains the app args but they don't appear in `args`),
            // try to extract them from Environment.CommandLine.
            if (args.Length == 0 || (args.Length == 1 && !args[0].Contains("--DataFolderPath") && !args[0].Contains("run-patcher")))
            {
                try
                {
                    var cmdLine = Environment.CommandLine ?? string.Empty;
                    // Look for the token 'run-patcher' and take everything after it as app args
                    var m = Regex.Match(cmdLine, "(?:\\s|\\\")run-patcher(?:\\s+)(.*)$", RegexOptions.Singleline);
                    if (m.Success)
                    {
                        var tail = m.Groups[1].Value.Trim();
                        if (!string.IsNullOrEmpty(tail))
                        {
                            Console.WriteLine("Parsed args from Environment.CommandLine.");
                            args = SplitArgs(tail);
                        }
                    }
                }
                catch (Exception ex)
                {
                    Console.WriteLine("Failed to parse Environment.CommandLine: " + ex.Message);
                }
            }

            return SynthesisPipeline.Instance
                .AddPatch<ISkyrimMod, ISkyrimModGetter>(RunPatch, new PatcherPreferences()
                {
                    ExclusionMods = new List<ModKey>()
                    {
                         new ModKey(AioPatchName, ModType.Plugin),
                         new ModKey("Nemesis PCEA.esp", ModType.Plugin)
                    }
                } )
                .SetAutogeneratedSettings("settings", "settings.json", out _settings)
                .SetTypicalOpen(GameRelease.SkyrimSE, AioPatchName)
                .Run(args);
        }

        public static void RunPatch(IPatcherState<ISkyrimMod, ISkyrimModGetter> state)
        {

            var AIOverhaul = state.LoadOrder.GetModByFileName("AI Overhaul.esp");
            var USLEEP = state.LoadOrder.GetModByFileName("Unofficial Skyrim Special Edition Patch.esp");
            if (USLEEP != null) System.Console.WriteLine("Unofficial Skyrim Special Edition Patch.esp");
            var UsleepOrder = state.LoadOrder.GetFileOrder("Unofficial Skyrim Special Edition Patch.esp");
            System.Console.WriteLine("at " + UsleepOrder);


            if (AIOverhaul == null)
            {
                System.Console.WriteLine("AIOverhaul.esp not found");
                return;
            }


            int bmax = 10;
            int b = 0;
            int processed = 0;
            int total = AIOverhaul.Npcs.Count;
            var updatedNpcs = new System.Collections.Generic.List<string>();
            int updatedCount = 0;

            var AIOFormIDs = AIOverhaul.Npcs.Select(x => x.FormKey).ToList();
            var winningOverrides = state.LoadOrder.PriorityOrder.WinningOverrides<INpcGetter>().Where(x => AIOFormIDs.Contains(x.FormKey)).ToList();
            //var USLEEPandPrior = state.LoadOrder.PriorityOrder.Reverse().Take(UsleepOrder + 1).Select(x => x.Mod).ToList();
            var masterfilenames = AIOverhaul.MasterReferences.Select(x => x.Master.FileName).ToList();
            var MasterFiles = state.LoadOrder.PriorityOrder.Reverse().Where(x => masterfilenames.Contains(x.ModKey.FileName)).ToList();
            var NPCMasters = MasterFiles.Select(x => x.Mod).NotNull().SelectMany(x => x.Npcs).Where(x => AIOFormIDs.Contains(x.FormKey)).ToList();

            var allOverrides = state.LoadOrder.PriorityOrder.Reverse().Skip(UsleepOrder + 1).Select(x => x.Mod).NotNull().SelectMany(x => x.Npcs).Where(x => AIOFormIDs.Contains(x.FormKey)).ToList();


            System.Console.WriteLine(processed + "/" + total + " Npcs");
            foreach (var npc in AIOverhaul.Npcs)
            {
                if (_settings.Value.IgnorePlayerRecord &&  new List<uint>() { 7, 14 }.Contains(npc.FormKey.ID)) continue;

                if (b >= bmax)
                {
                    b = 0;
                    System.Console.WriteLine(processed + "/" + total + " Npcs");
                }

                var winningOverride = winningOverrides.Where(x => x.FormKey == npc.FormKey).First();
                var Masters = NPCMasters.Where(x => x.FormKey == npc.FormKey).ToList();
                var winningMaster = Masters.FirstOrDefault();
                if (winningMaster == null) winningMaster = state.LoadOrder.PriorityOrder.Select(x => x.Mod).NotNull().SelectMany(x => x.Npcs).Where(x => x.FormKey == npc.FormKey).First();
                var overrides = allOverrides.Where(x => x.FormKey == npc.FormKey).ToList();



                bool change = false;

                var patchNpc = state.PatchMod.Npcs.GetOrAddAsOverride(winningOverride);
                if (npc.IsProtected() && !(patchNpc.IsProtected() || (patchNpc.IsEssential() && _settings.Value.MaintainHighestProtectionLevel)))
                {
                    patchNpc.Configuration.Flags = patchNpc.Configuration.Flags.SetFlag(NpcConfiguration.Flag.Protected, true);
                    change = true;


                }
                foreach (var fac in npc.Factions)
                    if (!patchNpc.Factions.Select(x => new KeyValuePair<FormKey, int>(x.Faction.FormKey, x.Rank)).Contains(new KeyValuePair<FormKey, int>(fac.Faction.FormKey, fac.Rank)))
                    {
                        patchNpc.Factions.Add(fac.DeepCopy());
                        change = true;

                    }

                if (!patchNpc.Packages.All(x => npc.Packages.Contains(x)) || !npc.Packages.All(x => patchNpc.Packages.Contains(x)))
                {
                    change = true;


                    var PackagesToRemove = Masters.SelectMany(x => x.Packages).Select(x => x.FormKey).Where(x => !npc.Packages.Select(x => x.FormKey).Contains(x)).ToHashSet<FormKey>();

                    var PackagesToAdd = overrides.SelectMany(x => x.Packages).Select(x => x.FormKey).Where(x => !PackagesToRemove.Contains(x)).Distinct().ToList();

                    if (PackagesToAdd.Count > 0 || PackagesToRemove.Count > 0)
                    {
                        var aioOrder = npc.Packages.Select(x => x.FormKey).ToList();
                        patchNpc.Packages.Clear();
                        PackagesToAdd.OrderBy(x => npc.Packages.Contains(x) ? aioOrder.IndexOf(x)  : (npc.Packages.Count + PackagesToAdd.IndexOf(x))).ForEach(x => patchNpc.Packages.Add(x));
                        
                    } 
                }




                var OverwrittenOutfits = Masters.Select(x => x.DefaultOutfit).Select(x => x.FormKey).Distinct().ToHashSet<FormKey>();
                var OverwrittenSleepingOutfit = Masters.Select(x => x.SleepingOutfit).Select(x => x.FormKey).Distinct().ToHashSet<FormKey>();

                FormKey? OverwrittingOutfit = overrides.Select(x => x.DefaultOutfit).Select(x => x.FormKey).Where(x => !x.IsNull && !OverwrittenOutfits.Contains(x)).Prepend(npc.DefaultOutfit.FormKey).LastOrDefault();
                FormKey? OverwrittingSleepingOutfit = overrides.Select(x => x.SleepingOutfit).Select(x => x.FormKey).Where(x => !x.IsNull && !OverwrittenSleepingOutfit.Contains(x)).Prepend(npc.SleepingOutfit.FormKey).LastOrDefault();

                if (npc.DefaultOutfit.FormKey != patchNpc.DefaultOutfit.FormKey)
                {
                    if (OverwrittingOutfit.HasValue && !OverwrittingOutfit.Value.IsNull)
                        patchNpc.DefaultOutfit.SetTo(OverwrittingOutfit);
                    else
                        patchNpc.DefaultOutfit.SetToNull();

                    change = true;

                }

                if (npc.SleepingOutfit.FormKey != patchNpc.SleepingOutfit.FormKey)
                {
                    if (OverwrittingSleepingOutfit.HasValue && !OverwrittingSleepingOutfit.Value.IsNull)
                        patchNpc.SleepingOutfit.SetTo(OverwrittingSleepingOutfit);
                    else
                        patchNpc.SleepingOutfit.SetToNull();
                    change = true;


                }
                if (npc.SpectatorOverridePackageList.FormKey != patchNpc.SpectatorOverridePackageList.FormKey)
                {
                    if (!npc.SpectatorOverridePackageList.IsNull)
                        patchNpc.SpectatorOverridePackageList.SetTo(npc.SpectatorOverridePackageList);
                    else
                        patchNpc.SpectatorOverridePackageList.SetToNull();
                    change = true;

                }

                if (npc.CombatOverridePackageList.FormKey != patchNpc.CombatOverridePackageList.FormKey)
                {
                    if (!npc.CombatOverridePackageList.IsNull)
                        patchNpc.CombatOverridePackageList.SetTo(npc.CombatOverridePackageList);
                    else
                        patchNpc.CombatOverridePackageList.SetToNull();
                    change = true;


                }

                if (npc.ObserveDeadBodyOverridePackageList != patchNpc.ObserveDeadBodyOverridePackageList)
                {
                    patchNpc.ObserveDeadBodyOverridePackageList.SetTo(npc.ObserveDeadBodyOverridePackageList);
                    change = true;
                }

                if (npc.Items != null && _settings.Value.MergeItems)
                {
                    if (patchNpc.Items == null )
                    {
                        patchNpc.Items  = new ExtendedList<ContainerEntry>();
                    }
                    foreach (var item in npc.Items)
                    {
                        if (!patchNpc.Items.Contains(item))
                        {
                            patchNpc.Items.Add(item.DeepCopy());
                            change = true;
                        }
                    } 
                } 


                if (npc.AIData.Confidence != patchNpc.AIData.Confidence)
                {
                    patchNpc.AIData.Confidence = (Confidence)Math.Min((int)patchNpc.AIData.Confidence, (int)npc.AIData.Confidence);
                    change = true;


                }


                if (npc.VirtualMachineAdapter != null)
                {
                    List<IScriptEntryGetter> ScriptsToForward = npc.VirtualMachineAdapter.Scripts.Where(x => patchNpc.VirtualMachineAdapter == null || !patchNpc.VirtualMachineAdapter.Scripts.Select(x => x.Name).Contains(x.Name)).ToList();
                    if (ScriptsToForward.Count > 0)
                    {
                        change = true;


                        if (patchNpc.VirtualMachineAdapter == null)
                            patchNpc.VirtualMachineAdapter = npc.VirtualMachineAdapter.DeepCopy();
                        else
                        {
                            ScriptsToForward.ForEach(x => patchNpc.VirtualMachineAdapter.Scripts.Add(x.DeepCopy()));
                        }
                    }

                }


                if (_settings.Value.IgnoreIdenticalToLastOverride && !change)
                {
                    state.PatchMod.Npcs.Remove(npc);
                }
                else if (change)
                {
                    updatedCount++;
                    string displayName = npc.FormKey.ToString();
                    try
                    {
                        if (npc.Name != null)
                            displayName = npc.Name.ToString() ?? displayName;
                        else if (winningOverride != null && winningOverride.Name != null)
                            displayName = winningOverride.Name.ToString() ?? displayName;
                    }
                    catch
                    {
                        displayName = npc.FormKey.ToString();
                    }
                    string masterSource = "unknown";
                    try
                    {
                        if (winningMaster != null)
                            masterSource = winningMaster.FormKey.ModKey.FileName;
                    }
                    catch { }
                    var entry = $"{displayName} ({npc.FormKey}) - source: {masterSource}";
                    updatedNpcs.Add(entry);
                    System.Console.WriteLine("Updated: " + entry);
                }
                b++;
                processed++;
            }
            // summary
            System.Console.WriteLine($"Updated {updatedCount} of {total} NPCs.");
            if (updatedCount > 0)
            {
                System.Console.WriteLine("Updated NPCs:");
                foreach (var e in updatedNpcs)
                    System.Console.WriteLine("  " + e);
            }
            if (state.PatchMod.ModKey.Name == AioPatchName)
            {
                state.PatchMod.ModHeader.Flags = state.PatchMod.ModHeader.Flags | SkyrimModHeader.HeaderFlag.Small;
            }
        }

        private static string[] SplitArgs(string commandLine)
        {
            var matches = Regex.Matches(commandLine, "[\"]([^\"]*)[\"]|'([^']*)'|[^ \t\r\n]+");
            var parts = new List<string>();
            foreach (Match m in matches)
            {
                var v = m.Value;
                if (v.Length >= 2 && ((v[0] == '"' && v[v.Length - 1] == '"') || (v[0] == '\'' && v[v.Length - 1] == '\'')))
                    v = v.Substring(1, v.Length - 2);
                parts.Add(v);
            }
            return parts.ToArray();
        }
    }
}
